/* 常量的定义 */
    //使用函数定义常量
    define('PI',3.14);

    //使用const定义关键字
    const El = 114514;

/* 变量 */
    Gettype(变量名);
    //获取该类型对应的字符串
    settype(值,类型);
    //设置类型 会改变原来类型

    (变量类型)值;
    //强制转换数据类型  不会改变原来类型

    is_变量类型(值);
    //判断变量

/* 循环 */
     switch($ClassName){ 
            case 匹配内容:
                执行体;
                break;

            //都不匹配时
            default:
                执行体;
        }

    exit();
    //结束代码
    continue;
    //重新循环 +'2'可以覆盖到外一层循环
    break;
    //跳出循环+'2'可以覆盖到外一层循环
    return;
    //返回值;

    ********HTML&&PHP*********
        混搭的{ === : ;
        混搭的} === endfor;

/* 字符串 */
    /* 结构化定义字符串 */
    heredoc结构
    $app = <<<EOD  或者'EOD' //边界符不允许有任何东西
        hello
            world
    EOD;                     //下边界符要顶格,只能跟;
    //对比双引号,结构化会保持相对格式 内容全部当成字符串,变量需要加单引号
    
    strlen($app);
    //计算字符段长度
    mb_strlen($app,'utf-8');
    //指定字符集，可以获得字数

    /* 转换 */
    lmplode(连接方式,目标数组);
    //将目标数组按规则转换成字符串
    Explode(分割字符,目标字符串);
    //按规则将字符串转换成数组
    Str_split(字符串,字符长度);
    //按照指定长度拆分,成数组

    /* 截取 */
    Trim(字符串[,指定字符]);
    //默认去除两边空格,也可以去除指定目标
    ltrim();
    //去除左边
    Rtrim();
    //去除右边
    Substr(字符串,起始位置[,长度]);
    //指定位置截取,不设定长度截取到末尾
    Strstr(字符串,匹配字符);
    //从匹配字符开始，截取到最后
     
    /* 转换大小写 */
    Strtolower();
    //全部小写
    strtoupper();
    //全部大写
    Ucfirst();
    //首字母大写

    /* 查找 */
    Strpos(字符串,'条件');
    //查找字符串首次出现的位置
    Srrrpos(字符串,'条件');
    //查找字符串最后一次次出现的位置

    /* 替换 */
    Str_replace(匹配目标,替换内容,字符串);
    //对匹配过的字符串替换

    /* 格式化输出 */
        sprintf("今年%d岁,我叫%s",$age,$name);
        //格式化输出内容

    /* 其他 */
        str_repea();
        //重复某个字符串N次
        str_shuffle();
        //随机打乱字符串

/* 转义 */
    \' 在字符串中识别单引号
    \" 同上
    \r 回到当前行的首位置
    \n 新一行
    \t 输出4个空格
    \$ 在php中使用$来声明变量

    单引号 不可以识别变量
    双引号 可以识别变量 {$app}

/* 数组 */
    /* 数组遍历 */
    //数组遍历
        arr=[1,2,3,4,5,'s','f','y','u'];
        oreach($arr as $key => $v){
           echo 'key=',$key,'value=',$v ,'<br/>';
        }
     
    echo count($arr);
    //获取数组长度

    in_arra y($arr);
    //判断数组是否存在

    array_reverse($arr);
    //翻转数组

    each($arr);
    //获取当前下标的函数,并且指针往后移动
    //如果无法获取,指针移动到最后,并且返回false

    List(变量1,,变量2.....)=$arr
    //数组按顺序赋值到变量


    /* 数组排序 */
        //排序
        // $a =sort($arr1);
        //需要赋值
        // print_r($arr1);
        //排序改变key

        // asort($arr1);
        // print_r($arr1);
        //排序不改变key

        // shuffle($arr1);
        // print_r($arr1);
        //打乱数组,改变key



/**************************系统函数******************************/
/* 输出函数 */
    print_r();
    //类似于var_dump();但是不会输出数据类型

/* 时间 */
    date();
    //格式化时间,如果无输入者输出输出当前时间的时间戳;
    time();
    //输出当前时间的时间戳;
    microtime();
    //输出微秒
     strtotime();
     //输入的中英转换成时间戳

/* 时间 */
    require;
    //载入文件,出错阻止运行;

    require_once;
    //只载入一次文件,出错不阻止;

    include;
    //载入文件,出错不阻止;

    include_once;
    //只载入一次文件,出错不阻止;

/* 数学 */

    max();
    //比较一个最大值;
    min();
    //比较一个最小值;
    rand();
    //在定义区间获取一个随机整数
    mt_rand();
    //在定义区间获取一个随机整数,效率更高(建议)
    round();
    //四舍五入;
    cell();
    //小数向上取整例 1.1 === 2
    floor();
    //小数向下取整例 1.9 === 1
    pow(1,2);
    //1的2次方1^2;
    abs();
    //绝对值
    sqrt();
    //平方根

/* 有关函数的函数 */
    function_exists();
    //判断函数是否存在

    func_num_args
    //获取形参个数

     func_get_arg();
     //获取形参相对参数

     func_get_args();
    //获取所有参数以数组返回
    
/* 错误 */
    trigger_error('警告内容',警告级别)
    //设置自定义错误警告,没办法阻止系统报错

    Error_reporting();
    //设置错误显示级别

    lni_set('配置文件中的配置',配置值);
    //页面开关错误级别显示

    set_error_handler('回调函数名字');
    //修改错误报告
    errno
    第一个参数 errno，包含了错误的级别，是一个 integer。
    errstr
    第二个参数 errstr，包含了错误的信息，是一个 string。
    errfile
    第三个参数是可选的，errfile， 包含了发生错误的文件名，是一个 string。
    errline
    第四个参数是一个可选项， errline， 包含了错误发生的行号，是一个 integer。
    errcontext
    第五个可选参数， errcontext， 是一个指向错误发生时活动符号表的 array。 
    也就是说，errcontext 会包含错误触发处作用域内所有变量的数组。 用户的错误处理程序不应该修改错误上下文（context）。

/* 错误日志 */
    在lni.php设置

    log_errors = on;
    //开启日志

    error_log = '日志保存路径';
    //设置日志路径

/* 魔术变量 */

/**************************系统函数END******************************/


/**************************函数******************************/
/* 函数 */
    &形参;
    //引用外部参数,这个形参必须是变量,而且运算的值会改变外部的变量

    return;
    //返回值,并且结束函数;

    //回调过程,被传入的函数成为回调函数
    sys_function('usre_function',10);
    //动态函数,把其他函数名定义到当前函数,
    return $arg1($arg2);
    //例,$arg1定义为函数名,返回输出;

    use($要调用上一级的变量);
    //闭包匿名函数/函数调用上一级函数的变量(不会销毁)

/* 作用域/跨域 */
    全局作用域的变量，局部作用域无法调用;
    常量无视作用域

    $GLOBALS['变量名'];
    //可以再函数内部调用,全局变量

    global  $app;//声明
    $app=3;      //修改
    //global 声明变量 全局和局部作用域都可以用
    //如果是全局有这个变量名，那么局部变量指向全局变量的地址,如果没有则新开辟一个
    //声明变量不能直接赋值

    static $app = 1;
    //静态变量声明,用于跨函数,共享数据
    (在本函数不会随着函数运行结束销毁的变量);



/**************************函数END******************************/
<pre>
</pre>
//格式更好看


/**************************MySQL数据库******************************/
【改中文表名】
SET NAMES GBK

【创建数据库】
CREATE DATABASE 数据库名字;

【查看已有数据库】
SHOW DATABASES;

【查看匹配的数据库】
SHOW DATABASES LIKE '数据库名%'; 

【查看指定数据库】
SHOW CREATE DATABASE 数据库名字;

【修改数据库编码方式】
ALTER DATABASE 数据库名字 DEFAULT CHARACTER SET 编码方式 COLLATE 编码方式_bin;
alter database 库名 charset 字符集

【删除数据库】
DROP DATABASE 数据库名字;

【选择数据库】
USE 数据表名字;

*********************************建库**********************************
【创建数据表】
还可以在表名字前加上数据库名字用‘.’连接；

CREATE TABLE 表名
（
字段名1，数据类型[完整性约束条件]，
字段名2，数据类型[完整性约束条件]，
id INT（11），
name VARCHAR（11），
grade FLOAT
）charset 字符集;
//设置字符集

【主键】
PRIMARY KEY;
//不允许为空,不允许重复 

【唯一键】
unique key
//保证数据的唯一性,可以存在多个,允许NULL
//如名字

【复合主键】
PRIMARY KEY(当前字段1,当前字段2);

【自动加1】
AUTO_INCREMENT;

【列描述】
comment '';
//给开发人员的注释说明

【插入无负数数据】
mysql默认数据大小有正负  例范围255 者-128 正127
 数据类型 unsigned

【不足显示长度填充0】
自动unsigned，负值无法使用
 数据类型 Zerofill



**************************建库END*****************************************
【查看表的创建结构】
SHOW CREATE TABLE 表名;

【复制已经有的数据表】
create 新表名 like 被复制表名；

【查看当前数据库所有表】
show tables;

【查看数据表】
SHOW CREATE TABLE 数据表名;
SHOW CREATE TABLE 数据表名\G;//可以美化ui

【更好看ui的查看数据表】
DESCRIBE 表名;
或简写
DESC 表名;
show columns from  表名；

【修改数据表，表名】
ALTER TABLE 旧表名 RENAME TO 新表名;

【修改字段名或数据类型】
ALTER TABLE 表名 CHANGE 旧字段名 新字段名 新数据类型;

【添加字段】
ALTER TABLE 表名 ADD 新字段名 数据类型;
（
[约束条件][FIRST|AFTER 已存在字段名]//可以不加约束条件
）

【修改主键】
ALTER TABLE `test2` DROP PRIMARY KEY 删除//增加ADD PRIMARY KEY ( `id` )

【修改字段类型】
alter table 表名 modify 字段名 数据类型（约束）；

【删除字段】
ALTER TABLE 表名 DROP 要删除的字段名;

【修改字段名顺序】
ALTER TABLE 表名 MODIFY 字段名1 一个）|AFTER（替换位置）字段名2;
//字段名1是定位，字段名2移动到字段名1上面。

【删除数据表】
DROP TABLE 表名;

【1.主键约束】
添加主键:alter table  table_name add primary key (字段)
删除主键:alter table table_name drop primary key

【2.非空约束】
添加:alter  table table_name modify 列名 数据类型  not null 
删除:alter table table_name modify 列名 数据类型 null

【3.唯一约束】
添加:alter table table_name add unique 约束名（字段）
删除:alter table table_name drop index 约束名

【4.自动增长】
添加:alter table table_name  modify 列名 int  auto_increment
删除:alter table table_name modify 列名 int  

【5.外键约束】
添加:alter table table_name add constraint 约束名 foreign key(外键列) 
references 主键表（主键列）
删除:

【删除外键】
alter table table_name drop foreign key 约束名

【删除索引】
alter  table table_name drop  index 索引名
[^1]: 
约束名和索引名一样

【默认值】
添加:ALTER TABLE <数据表名>CHANGE COLUMN <原字段名> <字段名> <数据类型> DEFAULT <默认值>;
删除:ALTER TABLE <数据表名>CHANGE COLUMN <原字段名> <字段名> <数据类型> DEFAULT NULL;

【指定字段插入】
INSERT INTO `student` (`name`, `gender`) VALUES
('Tom','男'),('Lucy','女'),('Jimmy','男'),('lijiaqi','86.5');

【省略字段插入】
INSERT INTO `student`  VALUES
(NULL,'Elma','女'),(NULL,'Ruth','女');

【查看表中所有数据】
SELECT*FROM `STUDENT`;

【删除部分数据】
DELETE FROM 表名 WHERE '字符段'=‘数据’；

【删除全部数据】
DELETE FROM '表名'

【清空数据表】
TRUNCATE `表名`

【删除数据库】
DROP DATABASE 数据库名字


【指定插入数据】
INSERT INTO 表名 （name，age，grade）
（'null','张三','18','男'）;

【插入内容】
INSERT INTO `student` (`name`, `gender`) VALUES
('Tom','男'),('Lucy','女'),('Jimmy','男'),('lijiaqi','86.5');

【浮点型】
Float  7个之内是准确的,超出不准确（4字节）
Float（10,2） 整数8位，小数2位

Double  15个精度（8字节）

Decimal（M，D）
定点数更加精确 M代表总长度不能超过65,
D代表小数长度不能超过30


【日期时间类型】
Date
mm-mm-dd格式，默认0000-00-00

Time
能表示指定时间 （3字节）HH:II:ss格式
时间范围大

Datetime
前两个合并 mm-mm-dd HH:II:ss格式

Timestamp
时间戳 mm-mm-dd HH:II:ss格式 格林威治时间开始
默认是当前时间  更细时刷新当前时间戳 

Year 
占用一个字节 两位数和四位数的数据插入

【字符串类型】
Char
中英字符数一样不能超过255

Varchar
变长字符，会根据数据计算数据长度分配空间，
但是不会超过最大长度0-65535字符数

text 
文本类型 2个字节存储 大小2^16+2

Enum（数据1，数据2）；
存储固定值如 男 女 

set（）
复选，指定数据


**************************高级操作*********************************************
【主键冲突】
字段lnsert into 表名 [列表] values 值列表 on duplicate key update 字段 = 新值;
//更新值

Replace into 表名 [字段列表] values 值列表 on duplicate key update 字段 = 新值;
//替换主键

【蠕虫复制】
insert into 生成的数据字段 select * from 抓捕的数据字段;

【更新数据】
Update 表名 set 字段名 = 新值 [where 判断条件/limit 数量];
//条件限制更新,如果不限制则是全表更新,或者限制更新次数

【高级删除】
DELETE FROM <表名>  [where 判断条件/limit 数量];


【重置id】
ALTER  TABLE  `表名` DROP `id`;
//删除id
ALTER TABLE 表名 add int(11) primary key not null auto_increment FIRST;
//添加自增id达到重置id

truncate table 表名
//重置id会删除数据;

【删除所有数据保留结构】
Truncate 表名;
&&
truncate table 表名
(会删除所有数据)

【完整查询指令】
Select select 选项 字段列表 Fron 数据源 where 条件 group by 分组 having 条件 order by 排序 limit 限制

//Select 系统对待查询到的结果
//all；默认的，保存所有记录;
//distinct 去除重复数据;

【多表查询/别名】
[as] 别名;
例如:
select user.name,user1.name from user,user1;


【查询表单字段】
SELECT id,name,acve FROM URSE;
          (字段)                          （表名）

【查询表单所有字段】
SELECT*FROM `表名`;

【按条件查询】
SELECT id,name,acve FROM urse WHERE id<4;
       (字段名)                         （表名）        （条件）

【IN关键字查询】(查询指定的）
SELECT * FROM urse WHERE id IN(1,5,3);
 （可以是字段）

SELECT * FROM urse WHERE id NOT IN(1,5,3);
                          (NOT = 不查询)        

【BETWEEN AND关键字查询】
SELECT * FROM urse WHERE id BETWEEN 2 AND 5;
                        (id 范围查询2 - 5 的字段）

【空值查询】
SELECT * FROM urse WHERE acve is null;   （NOT null 就是不为空值）
                   （查询acve字段为空值的数据）

【DISTINCT 关键字的查询】
SELECT DISTINCT name FROM urse; （查询“类？”不重复，过滤查询）
               (字段名）（表名）

【LIKE 通配符查询】
SELECT * FROM urse WHERE acve LIKE '9%';
              （表）    （字段）   （查询的开头）（9_ 也可以一个字符对应一个_）

【AND多条件查询】
SELECT * FROM urse WHERE id<3 AND LIKE '95';

【指定条件删除】
delete from 表名 where 条件判断；
//如果没写条件,系统会删除所有数据（（慎用））

【修改匹配字段】
update 表名 set 字段名 = 新值 where 判断条件； 
//如果没写条件,系统会修改所有指定字段（（慎用））

【获取动态数据】
select * From (select 字段列表 from 表)as 别名;
//在本表里获取其他的表,以别名合并显示到本表

【条件筛选】
where id <=10;

【分组统计】
group by 字段名;
//为了数据统计,如男生多少人

【统计函数】(聚合函数)
count();//统计每组的数量,不统计null的字段
avg();//求平均值
sum();//求和
max();//最大值
min();//最小值

例：
select 表名,count(*//统计全部),max(),min(),gvg() from 数据库名 group by 表名;

【字符段拼接】
Group concat();
//对应字段拼接起来

【多分组】
group by 字段名1,字段名2;
//先按照1排序,取得结果后再和2进行排序

【分组判断】
Having  <= name;
//聚合函数后运行判断语句

【排序】
Order by 字段 [asc|desc];
//默认asc 升序 desc 降序
//可以多字段排序 

【限制获取】（用于分页）
SELECT * FROM 表名
limit 0,1  //从零开始获取两条数据
//offset 从哪里开始
//length 具体获得多少条
//用来限制获取的数据

【联合查询】
(Select * from 表名 where 字段名<=判断条件 order by 别名 asc limit 10)
Union [union 选项]
(Select * from 表名 where 字段名<=判断条件 order by 别名 desc limit 10)

all //获取全部数据,因为默认去重复
//如果联合查询要筛选需要加括号和limit 才能生效

**************************高级操作END******************************************

**************************运算符******************************************
【逻辑运算符】
and 逻辑与
or 逻辑或 
not 逻辑非
in(字段1,字段2)  存在就输出
is null 是否为空
is not null 是否不为空
【模糊匹配】
like '小%' ;
_ 匹配对应的单个字符
% 匹配多个字符
例如
SELECT * FROM `user1` WHERE name LIKE '小%';
**************************运算符END***************************************

**************************连接查询******************************************
【交叉连接】
select *from 表名 cross join 表名2;

【内连接】
select *from 表名 inner join 表名2 on 表1.id=表2.id ;

【外链接】
outer join;
//按照某一张主表,根据条件去链接另一张表;
[左外连接]
select * from 主表 left join 从表 on 连接条件;

[右外连接]
select * from 从表 right join 主表 on 连接条件;

【uslect字段】
select * from 从表 right join 主表 using(id);
//代替on 只能匹配相同字段的数据,只返回一个匹配字段

【子查询】
//标量子查询
-查询结果:一行一列
条件:搜索叫xx名字人所在的班级
基本语法：select * from 数据源 where 条件判断 =/<> (sl\elect 字段名 from 数据源 where 条件判断);
案例： select * from 要获取数据的表 where 判断字段 =(select 字段 from 数据表 where = 条件); 
//查询薇琳是那班的
select class from mi_class where name =(select name from mi_name where name = '薇琳');

//列子查询
-查询结果:一列多行
条件:获取已经有人在的房间(返回集合体)
基本语法:where 条件 in (列子查询)
案例:select 查询字段 from 表名 where 条件字段 in(select 字段条件 from 表名);
//查询1班有谁
select name from mi_name where name in (select name from mi_class);


//行子查询
-查询结果:一行多列
条件:获取年龄最大和身高最高的人(多条件查询)
基本语法:主条件 where 条件 (行元素)
案例:select * from  表名 whele (判断字段1,判断字段2) = (select max(判断字段1),max(判断字段2) from 表名)
//查询身高最高的
select * FROM mi_name where (height) =(select max(height) from mi_name);

//表子查询
-查询结果:多行多列
条件: 获取每个班身高最高的
基本语法:select 字段 from(表子查询) as 别名[where][group by] [having]
案例:select *  from (select * from 班级字段 order by 高度字段) as 别名 group by id字段; 
//查询1班最高的反着排序
select * from (select * from mi_name where name in(select name from mi_class where class='1班')) as c order by height  desc;


//Exists查询
-查询结果:返回1&&0,1==ture 0==false
条件: 求出,有学生在的班级
基本语法:where exists(查询语句)
//exists根据查询的结果进行判断
案例:select * from 表名 whele  exists(select id判断字段 from 表名)

in ：连接列子查询
=any()：列子查询匹配到任何一个查询结果即可
<>any():不等于其中的所有数
Some :和any一样
all：等于所有
<>all：不等于所有
null 不参与运算
**************************连接查询END******************************************


**************************备份与还原******************************************
【SQL备份】
`win系统下`
mysqldump.exe -hlocalhost -P3306 -uroot -proot 数据库名字[表1 [标2....]] > 备份文件地址
//备份数据库结构,但不适合频繁备份,整库\单表\多表

【SQL还原】
`win系统下`
1.Mysql.exe -hlocalhost -P3306 -uroot -proot 数据库 <文件位置 --default-character-set=utf8//字符集
`Mysql里`
2.Source Sql文件位置;

**************************备份与还原END****************************************

**************************用户创建******************************************
【创建用户】
create user '用户名'@'%' identified by '密码';
//@ 是指指定的链接主机地址

【创建无密码用户】
create user '用户名'
//不限制主机 没有密码(不安全)

【查看用户】
select * from mysql.user;//查看全部用户
SELECT * FROM mysql.user WHERE user = '指定用户';

【删除用户】
drop '用户名'@'主机地址';

【修改密码】
1、基本语法
set password for '用户'@'%' = password('新密码');
2、更新语句
update mysql.user set password  = password('新密码') where user = " and host =";

【权限管理】
grant 权限列表 on 指定表/库(*.*代表全部) to '用户'@'%';
案例：
grant SELECT on  *.* to 'kaiLu'@'%';

【取消权限】
revoke 权限列表/all privileges on 指定表/库 from '用户'@'%';

【刷新权限】
//刷新将权限写入在表里
flush privileges;

【重置ROOT密码】
1、停止mysql服务
net stop mysql
2、重启mysql服务但是跳过权限
mysql.exe-skip-grant-tables
3、修改root密码
update mysql.user set password  = password('新密码') where user = 'root' and host ='localhost';
4、关闭服务器，并且重启

**************************用户创建END******************************************

*****************************外键***********************************
【创建外键】
1、在字段后增加一条语句
[constraint `外键名`] foreign key(外键字段) references 主表(主键)
案例:foreign key (class_id) references my_class(class_id)

2、创建表后增加外键
Alter table 从表 [add constraint `外键名`] foreign key(外键字段) references 主表(主键);
案例:alter table mi_class add constraint `mi_class_name` foreign key (name) references mi_name(name)

【外键选择性约束】
Alter table 从表 [add constraint `外键名`] foreign key(外键字段) references 主表(主键) on 约束条件;
1、district 严格模式 默认 (不允许操作)
2、cascade  级联模式 一起操作
3、set null 置空模式  主表(删除)从表变空
4、外键约束对象是主表操作(删除),从表只是不能插入主表不存在的数据

[常用的约束]
on update cascade,on delete set null,
更新级联,删除置空

【更新主表】
update 数据表 set 字段 = 新数据 where 字段 = 被修改数据：

【删除外键】
alter table 从表 drop foreign key 外键名字;
案例1：alter table mi_class drop foreign key `mi_class_name`;

【删除主表引索】
alter table mi_class drop index `mi_class_name`;

1、外键与关联的字段类型必须一致例如int
2、基本属性相同
3、表后增加外键,对数据源有要求(从表数据与主表数据的关联关系)
4、外键只有innodb存储引擎能使用

【外键的运用】
1、主表约束从表
例如 主表字段有1-4班,从表不能插入1-4班以外的数据
2、不可以删除数据
3、外键约束对象是主表操作(删除),从表只是不能插入主表不存在的数据

*****************************外键END***********************************

*****************************视图***********************************
【创建视图】
create view 视图名 as
select * from 表1 as a left join
表2 as b
on a.字段 = c.字段;
//字段名不能有重复
using(字段);
//用于重复字段名

【查看视图】
select 字段表 from 视图名字[字句];

【视图修改】
alter view 视图名字 as 新 select 指令;

【删除视图】
drop view 视图名字;

*****************************视图END***********************************

*****************************事务**************************************
【自动事务】
insert into 字段名 values(4,'4班');

【查看自动事务】
show variables like 'autocommit%';

【关闭自动事务】
set autocommit = off;

【提交事务】
//关闭自动事务后,手动提交
Commit :提交到数据库(同步)
Rollback :回滚(清空之前的操作)

【手动事务】
start transaction;
//开启事务,这条语句之后的都会写入日志

【提交手动事务】
Commit :提交到数据库(同步)
Rollback :回滚(清空之前的操作)

【回滚点】
[添加回滚点]
savepoint 回滚点名字;

[回到回滚点]
rollback to 回滚点名字;
*****************************事务END***********************************

*****************************MySQL变量***********************************
【系统变量】
1、查看全部系统变量
show variables[like 'patten//变量名'];

2、用户查使用 select 查询系统变量的数值
select @@变量名;

【修改系统变量】
1、修改系统变量当初连接有效,改了当次有效
set 变量名 = 新值

2、全局修改
set global 变量名 = 值;
//只对新客户端生效
set @@global.变量名 = 值;

【会话变量】
//跟用户绑定的变量
set @变量名 := 值;
:= //赋值

【表数据赋值到变量】
1、
select @name :=字段1,@age := 字段2 from 表名 limit 1;
2、
select 字段1,,字段2 from 表名 order by 排序条件 desc//降序 limit 1 into @name,@age;

【查看变量】
select @变量名;


【局部变量】
1、局部变量是用declare声明的
2、局部变量出现在begin和end1之间(函数/触发器/储存过程)
3、声明语法:declare 变量名 数据类型 [属性];
*****************************MySQL变量END***********************************


*****************************流程结构**************************************
【if分支】
1、用于select查询当中,当做一种条件来进行判断
if(条件,为只真结果,为假结果);
案例：select *,if(height >170,'符合身高','不符合') as judge//别名 from mi_name;

【if判断复杂语句块】
if 条件表达式 then
    满足条件要只想的语句
end if;

【if 复合判断】
if 条件表达式 then
    满足条件要只想的语句
else
    不满足条件要执行的语句
end if;

【whlie循环】
whlie 条件 Do
    要循环的循环体
end whlie;

【循环结构标识符】
标志名字:whlie 条件 Do
    要循环的循环体
end whlie [标志名字];

1、迭代,以下代码不执行,重新开始循环
lterate
2、离开,整个循环终止
leave
案例:
标志名字:whlie 条件 Do
    if 条件判断 Do
        循环控制
        leave 标识名字
    end if;
end whlie [标志名字];

*****************************流程结构END***********************************

*****************************函数***********************************
【访问函数】
select 函数名(参数列表);

【系统函数】
char_length()
//判断字符串字符数
length()
//判断字符串的字节数(与字符集相关)
Concat()
//连接字符串
instr()
//判断字符在目标字符串中是否存在,是返回位置,否返回零
lcase()
//全部小写
left()
//从左侧开始截取指定位置字符串
ltrim()
//消除左边对应的空格
mid()
//从中间指定位置开始截取,如果不指定长度,直到最后

【时间函数】
//搭配 select使用
Now()
//返回当前时间,日期 时间
curdate()
//返回当前日期
curtime()
//返回当前时间
Datediff() //是字符串,前大后小
//判断两个日期之间的天数
date add(日期,interval 时间数字 type day);
//增加时间
Uinx_timestamp();
//获取时间戳
from_unixtime();
//时间戳转换成日期

【其他函数】
Md5();
//对数据进行md5加密
Version();
//获取版本号
databse()
//显示当前所在数据库
UUID();
//生成一个唯一标识符(自增长)

【自定义函数】
修改临时结束符 delimiter 新符号//一般$$
后结束语句用 新符号
修改回语句结束符号delimiter ,;

【创建自定义函数】
delimiter $$ (改结束符)
Create function 函数名 ([形参1 数据类型,形参2 数据类型.....]) returns 返回值类型[int] 
Begin//开始
    //函数体
    return 返回值数据 
end//结束 语句结束符
delimiter ;(改回来)

【查看函数】
show funcyion status [like 'pattern'];

【查看函数的创建语句】
show create function 函数名字;

【调用函数】
select 函数名(实参);

【删除函数】
drop function 函数名;

【变量作用域】
1、局部声明
declare
2、会话作用域
set @变量名
3、全局作用域
set global 变量名 = 值;
set @@global.变量名 = 值;

*****************************函数END***********************************

*****************************存储过程***********************************
【创建存储过程】
Create procedure 过程名字([参数列表])
Begin//开始
    //过程体

end//结束
结束符

【查看存储过程】
show procedure status [like 'pattern'];

【查看过程结构】
show create procedure 过程名字;

【调用过程】
call 过程名([实参]);

【删除过程】
drop procedure 过程名字;

【存储过程类型参数】
IN
//表示参数从外部传入到里面使用(过程内使用);
可以说是直接数据也可以是保存数据的变量
Out
//表示参数是从过程里面把数据保存到变量中,交给外部使用、
传入的必须是变量,如果传入的变量有值进入后被清空;(里面往外传数据)
Inout
//数据可以从外部传入到过程内部使用,内部处理后反回给外部


【触发器】
Create trigger 触发名字 触发时机 触发事件 on 绑定的表 for each row
Begin
    //内容
end;
//触发对象：on 表 each row 触发器绑定实质是表中所有的行,因此表中每一行发生改变时
就会触发触发器
1、
Before:在表中数据改变前的状态
2、
after:在表中数据改变后的状态

【触发事件】
insert //插入操作
update //更新操作
dlete  //删除炒作


【查看触发器】
1、查看触发器
show triggers;

2、查看触发器的创建语句
show create tigger 触发器名字;


【删除触发器】
drop trigger 触发器名字;

【触发器关键字】
new 
//改变后的数据
old
//改变前的数据

【触发器实例】
//商品自动扣除库存
delimiter $$
Create trigger 触发名字 alter insert on 绑定的表 for each row
Begin
    update  商品出库表 set 字段名 = 字段名 - 出库数量字段  where id = new.商品字段
    //更新商品   new代表新增的订单
end
$$
delimiter ;

//判断库存是否够扣
delimiter $$
Create trigger 触发名字 before insert on 绑定的表 for each row
Begin
        selecr 库存字段 from 数据表 where id = new.id into @inv;
        //数据取出 并且赋值

        if @inv < new.取出数量字段 then
            insert into xxx values ('xxx');
            //如果成立暴力中断
        end if;
end
$$
delimiter ;
*****************************存储过程END***********************************
/**************************MySQL数据库END******************************/

/**************************PHP核心编程******************************/
/* 设置PHP文件字符集 */
    header('Content-type:text/html;charser=utf-8');

/* 表单上传 */
    Get 
    1、获取传递数据
    2、搭配a标签和js多样化使用
    Post
    1、上传表单

    /* 上传复选框 */
        1、checkox(多选框)
        <input type="checkox" name="名字[]" value="xxxx">
        <input type="checkox" name="名字[]" value="xxxx">
        //保证完整一组数据，不会因为同名覆盖;

        2、radio(单选框)
        <input type="radio" name="gender" value="1" checked="checked"(默认选择)>男
        <input type="radio" name="gender" value="2">女

/* 表单接收 */
    $_GET //接收GET方式提交的数据
    $_POST //接收POST方式提交的数据
    $_ERQUEST //接收以上两种格式的数据

/* 数组分隔符 */
    implode('分隔符',数组)
    //数组转换字段并且加上分隔符
    Explode('分隔符',数组)
    //吧转换后的字符串变成数组 

/* 文件上传 */
    【from表单】
    1、method='Post'  
        上传文件只能用POST格式
       
    2、enctype="multipart/form-data"
    //规范上传数据的编码

    【input,file选择文件】
        <input type="file" name="imge">

    【$_FILES,获取用户上次文件】
        $_FILES['name名字']['name']
        //文件实际名字

        $_FILES['name名字']['tmp_name']
        //文件上传到服务器的临时路径

        $_FILES['name名字']['type']
        //文件格式

        $_FILES['name名字']['size']
        //文件大小(字节)

        $_FILES['name名字']['error']
        //文件上传的代号,告知文件上传出现了什么问题
    
    【临时文件移动到目标目录】
        1、赋值
        $file=$_FILES['name名字']
        
        2、判断否是上传文件/临时文件
        is_uploaded_file($file['temp_name'])

        3、将上传的文件移动到新位置
            move_uploaded_file($file['tmp_name'],'路径'.$file['naem'])
    
    【】

/* 多文件上传 */
    1、同名
    <input type="file" name="image[]">.....
    //同名文件遍历获取文件
    //判断文件和数组是否存在
    if(isset($_FILES['image']['naem']) as is_array($_FILES['image']['naem'])){
        //声明储存数据的数组
        $images = array();
        foreach($_FILES['image']['name] as $k(键) => $file(值)){
            $images[]=array(
                'name' => $file,
                'type' =>$_FILES['image']['type'][$k],
                'tmp_name' =>$_FILES['image']['tmp_name][$k],
                'error' =>$_FILES['image']['error'][$k],
                'size' =>$_FILES['image']['size'][$k],
            )
        }
    }
    
    2、不同名,形成独立的五个数据
    <input type="file" name="image1">.....
    //遍历下标上传每一个选择的数据
    foreach($_FILES as %file){
        //$file相当$_FILES于下标,判断是否存在文件
        if(is_uploaded_file($file['tem_name'])){
            //是,把临时文件放到指定根目录
            move_uploaded_file($file['tmp_name'],'目录地址'.$file['name']);
        }
    }

/* MySQL连接*/
    1、
    maysql_connect(服务器地址,用户名,密码) or die("'数据库连接失败：' . mysqli_connect_error()")

    2、
    $link = @maysql_connect(服务器地址,用户名,密码)
    //赋值
    if(!$link){
    exit('数据库连接失败：' . mysqli_connect_error());
    }
    //判断是否连接成功，否者返回原因
    mysqli_set_charset($link, 'utf8');
    //以utf-8字符集连接数据库

/* MySQL&PHP指令 */
    【PHP执行sql指令】
    mysqli_query();

    【选择数据库】
    mysqki_select db('数据库')

    【断开与数据库的连接】
    mysqli_colse($link)

    【获取结果集数据条数：多少行记录】
    mysql_num_rows()

   /* MySQL资源集 */
        [把MySQL资源集转换成PHP的数组,并且每次运行下标往后移动一位]
        mysql_fetch_assoc();
        //获取关联数组并且以表单名字作为下标，返回数组

        mysql_fetch_row();
        //获取关联s并且以索引数组[0~9]作为下标，返回数组

        (推荐使用)
        mysql_fetch_array('$sql',[MYSQL_BOTH])
        //默认MYSQL_BOTH获取表单名和索引值下标的数组
        MYSQL_ASSOC:只获取表单名下标
        MYSQL_NUM:只获取索引值下标

    /* MySQL扩展 */
        【字段信息相关】
        mysql_num_fields('$sql');
        //获取一个指定结果集中所有的字段数

        mysql_field_name('$sql',1);
        //获取一个指定结果集中指定字段的名字

        【错误信息相关】
        mysql_error()
        //获取mysql出错相应的提示信息

        mysql_errno()
        //获取mysql出错相应的代码

        exit()
        //终止代码执行

        【其他函数】
        mysql_insert_id();
        //获取上次插入所产生的自增长id，如果没有自增长id者返回0

    /* 增加数据 */
        【获取POST上传的数据】
        $name = isser($_FILES['name'])? trim($_FILES['name']):'';
        //判断数据是否为空， trim清除前面空格;

        header('refresh:3;url=news_add.html');
        //三秒后跳转到指定的页面，header前面不能有输出(置顶)

        CURRENT_TIMESTAMP  //sql语句
        //如果数据库的tiem设置是插入数据时写入时间,php的sql要写这个

    /* 查询数据库数据 */
        <?php foreach【遍历】(执行语句): ?>
            html代码
        <?php endforeach; ?>
        //PHP包含html执行

/* HTTP协议 */
    <>              <>              <>           <>
    header('Content-type:text/html;charset=utf-8');
    //设置打开方式为html，字符集为utf-8

    【浏览器接收】
    Request Headers
    //请求
    Response Headers 
    //服务器返回体

    【HTTP请求】
    [请求行]
    1)形式：请求方式 资源路径 协议版本号
    2）GET /index.php HTTP/1.1

    [请求头]
    1)host                请求的主机地址(必须)   
    Connection:keep-alive 保持连接    
    2)Accept              当前请求能狗接收服务器返回的类型(MIME类型)
    3)Accept-Language     接收的语言
    Accept-Encoding       数据压缩格式
    4)user-Agent          用户浏览器的各种信息


    [请求体]
    1)只有POST会产生的请求体
    2)基本格式:资源名字=资源值&资源名字=资源值


    【HTTP响应】
    [响应行]
    1)形式：协议版本号 状态码 状态消息
    2)200 ok  成功
    3)403     没有权限访问
    4)404     找不到页面
    5)500     服务器出错

    [响应头]
    1)时间:wod
    2)服务器:Server
    3)内容长度:Content-Length
    4)内容类型:Content-type
    5)keep-Ailce:timeout=5(最多连续连接5秒) max=100(最多请求100次)

    【HTTP响应设置及使用】
    1)Location:重新定向,立即跳转(响应体不用解析)
    //判定响应行;响应头;响应体;遇到locahost后不再解析后面的代码

    2)Refresh:重新定向,定时转跳(响应会解析)

    3)Content-type:内容类型，mime
    //设置浏览器字符集

    4)Content-disposition:内容类型,MIME类型扩展,激活浏览器文件下载对话框
    //激活下载

    [php通过header来实现设置HTTP]
    1)Content-type
    header('Content-type:text/html;charset=utf-8');
    //设置打开方式为html，字符集为utf-8

    2)Location:重新定向,立即跳转(响应体不用解析)
    header('Location:xxx.php')
    //立即跳转不执行后面的

    3)Refresh:重新定向,定时转跳
    header('Refresh:3;url=xxx.php')
    //3秒后跳转,并解析后面的代码

    4)Content-disposition,内容下载
    header('Content-disposition:attachment;filename=girl.jpg');
    //激活下载后面解析体         //附件       //名字

/* PHP模拟HTTP请求 */
    【CURL扩展模拟HTTP请求】(模仿用户操作,防止服务器url暴露)
    //1)开启curl会话
         $ch=curl_init();
        var_dump($ch);
    //2)设置curl传输设置
        // CURLOPT_URL:连接对象
            curl_setopt($ch,CURLOPT_URL,'newmal.xyz/setopt.php');//连接选项

        // CURLOPT_RETURNTRANSFER:将服务器(响应)执行结果以文件流的格式返回(php脚本)
            curl_setopt($ch,CURLOPT_RETURNTRANSFER,true);//文件流返回(数据)不直接显示

        // CURLOPT_PORT:是否发起POST方式请求(默认GET)
            curl_setopt($ch,CURLOPT_POST,TRUE);//使用post传输

        // CURLOPT_POSTFIELDS:用来传递数据[字符串/数组];
            curl_setopt($ch,CURLOPT_POSTFIELDS,'传输的内容');//要传输的字符串/数组
     
        // CURLOPT_HEADER:是否响应header信息(响应头)
            curl_setopt($ch,CURLOPT_HEADER,0);//是否响应文件头信息(不要)

    // 3)执行请求:curl_exec():执行选项(与服务器发起请求)得到返回的数据
        $content=curl_exec($ch);
        echo $content;
    // 4)关闭连接:curl_close():关闭资源
        curl_close($ch);

/* PHP文件目录操作 */
     @:错误抑制符
    【创建文件目录】
        [@]mkDir(路径名字);返回布尔值
    【删除文件目录】
        [@]rmDir(路径名字);返回布尔值

    【读取目录】
        openDir(路径);
        //打开指定路径并返回目录下所有的文件
        readDir(路径);
        //从资源获取所在位置的文件，输出并且指针向下移动(直到结束)
    
    【关闭资源】
        closedir();

    【其他目录操作】
        dirname(路径/文件);
        //获取上一层文件路径

        realPath((路径/文件);
        //得到真实路径(目录路径),文件返回false

        is_dir();
        //判断是否是目录返回布尔值

        scandir();封装 openDir(查) readDir(转)closedir(关)，
        //获取目录下的所有信息以数组方式返回

    【递归遍历目录】
        [需求]
        1)设计一个能够遍历一层文件的函数
            a、创建函数
            b、判断是否是路径
            c、遍历输出

        2)找到递归点:遍历的是目录,应当调用自己(函数)
            a、需要构造路径(遍历只是得到文件名字)
            b、需要排除.和..
            c、判断是路径还是文件
        3)找到递归出口：发现已经没有文件夹后停止调用自己(函数)
        4)如何显示层级关系
            a、str_repeat('输出的东西',输出的次数);用默认值声明

/* PHP文件操作 */
    【PHP5常见操作】
        file_get_contents(文件路径)
        //获取指定文件的所有内容;不存在返回布尔值
        file_put_contents(文件路径,内容)
        //指定内容写入到指定文件内;不存在直接创建一个
        //txt文本插入 "\r\n" *双引号 换行
    【PHP4常见操作】
    //以资源形式处理,都依赖指针
        1)fopen(文件路径,打开模式);打开一个文件资源
        2)fread(资源,长度);从打开的资源读取指定长度的内容
        3)fwrite(资源,路径);向打开的资源中写入指定的内容
             //txt文本插入 "\r\n" *双引号 换行
        4)fclose(资源);关闭资源
            [打开模式、资源指针]
                'r'只读,指针在头
                'r+'读写,指针在头
                'w'写入,内容清空指针在头,不存在就创建
                'w+'读写,内容清空指针在头,不存在就创建
                'a'写入,指针最后,不存在就创建
                'a+'读写,指针最后,不存在就创建
                'x'创建，写入，开头，否返回布尔值
                'x+'创建，读写，开头，否返回布尔值
    
    【其他文件操作函数】
        1)is_file() //判断文集是否正确(不识别路径)返回
        2)filesize()//获取文件大小
        3)file_exists()//判断文件是否存在(识别路径)
        4)unLinl();取消文件名字与磁盘地址的连接(删除)
        5)filemtime();获取文件最后一次修改的时间
        5)fseak();设定fopen打开的文件的指针位置
        6)fgetc();一次获取一个字符
        7)fgets();一次获取一个字符串(默认读一行)
        8)file();读取整文件,按行为下标返回数组(读行)
        9)feof();查询指针是否到达内容最后,返回布尔值
    【文件下载】
        //服务器通过HTTP协议传输给网页存储(尝试解析)
        //PHP下载:读取内容,以文件流传递,响应头中阻止解析,激活下载框
        //指定转码
        iconv('转换的编码','被转换编码', 值);

        1)指定浏览器解析字符集
        2)设置响应头
            a、设置文件返回的类型:image/jpg||application/octem-stream
            b、设定返回文件的计算方式(字节):Accept-ranges:bytes;
            c、设置下载提示/附件名字:Content-disposition:attachment;filename='文件名字';
            d、设定文件大小:Accept-length:文件大小;
        3)读取文件
        4)输出文件
            a、文件较小
                echo file_get_contents($file);
            b、文件较大,带宽拉胯,PHP4分段式读取
                $f=@fopen($file,'r')or die();
                //1)推荐
                while($row =fread($f,1024)){//一次读取1024
                    echo $row; //循环把数据全部分段输出
                }
                //2)
                while(!feof($f)){//一次读取1024
                    echo fread($f,1024); //循环把数据全部分段输出
                }
    【获取当前路径文件的名字】
        basename  
            basename('D:\New_MaI\img\小孩子不能看.jpg');
            //输出小孩子不能看.jpg

/* 会话技术 */
    /* cookie技术 */(简单数据)
    //服务器保存在客户浏览器的文件(HTTP响应头)大小(20个4k长度)
    //cookie技术:服务器通过HTTP响应存储到浏览器,浏览器携带返回到服务器
        1) Setcookie函数用来设定COOKIE信息
            a、Setcookie(名字,值,[结束时间],[作用范围],[有效域名/主机]);

        2)cookie名等等设置:字符串：
        3)cookie值的设置：第二参数
        4)cookie值的类型要求：简单类型中的整数/字符串
        
        【COOKIE生命周期】
        //指COOKIE在浏览器存在的时间
            1)默认生命周期:浏览器关闭结束
            2)设定一个常规日期的周期：通过第三个个参数设置生命周期(时间戳)
                a、setcookie('a','阿帕奇',time()+7*24*60*60);
                    //当前时间戳+7天的倒计时结束当前COOKIE(单位秒)
            
            3)设定为'0'的周期:和默认一样,关闭浏览器结束
            4)删除COOKIE的做法(注销):可以设置空内容/无效时间戳
                a、setcookie('a','阿帕奇',time()-1);

        【COOKIE高级使用】
            [Cookie作用范围]
            默认限制:子查父,父不能查子(文件夹)
            1)默认:上层看不见下层,下层可以看上层内容
            2)设定全局可用:"/"告知浏览器COOKIE作用于网站根目录
                a、setcookie(名字,值,生命周期,"/");

        【COOKIE跨子域】
            //在同一级别域名下:loliyaozi.xyz(一级域名)下有多个子域名可用设置共享COOKIE
            1)设定COOKIE的有效域名:设置COOKIE第五个参数控制访问
                a、setcookie('loli','yaozi',0,'/','newmal.xyz');
                    //设定本都域名
            2)不设置时的默认有效域名:默认当前域名(主机),不同域名(主机)之间不能共享COOKIE
            3)跨子域的设置方法:在设定域名访问的时候设定上局域名即可
                a、setcookie('newloli','newloli',0,'/',"newmal.xyz");
                    //在其他地方叫xx.newmal.xyz都可以使用COOKIE
                    //子域名必须是XX.一级域名;

        【COOKIE数组】
            //因为PHP的特殊性能存储伪数组
            1)创建COOKIE伪*数组
                setcookie('goods_id[0]',1);
                //二维数组
            2)输出伪数组
                echo '输出：'.$_COOKIE['goods_id'][0];

    /* session技术 */(安全)(复杂数据)
        //数据存储在服务端,依赖cookie,实现跨脚本共享数据
        //session_start开启第一次连接服务器,返回sessionID后,携带值通过COOKEI返回服务器
        //可以用sessionID判断是否是第一次登陆
        【开启session】
            session_start()
            //开启session,后生成$_SESSION;

        【设置session数据】
            //值可以是字符串/数组
                $_SESSION['name']='值';

        【读取session数据】
            //要先开启session
            //调用session
            echo $_SESSION['name'] ;

        【删除SESSION】
        //相当于将值清除
            1)删除一个SESSION数据
                a、Unset($_SESSION['下标']);
            2)删除全部SESSION数据
                a、$_SESSION = array();
                //清空所有下标

        【session基础配置】(php.ini修改)
            1)session.name:COOKIE返回头里sessionID里的名字 
            2)session.aotu.start:自动打开session_start(默认关闭)
            3)session.save_handler:数据的保存方式,默认是文件形式
            4)session.save_path:文件默认存储位置
                a、默认是系统的tmp临时文件存储(不安全)建议修改
            [常用配置]
                1)session.cookie_lifetime:sessionID在COOKIE里的生命周期
                    a、默认浏览器结束关闭
                2)session.cookie_path:session在网站目录访问等等范围
                    a、默认网站根目录
                3)session.coolie_domain:COOKIE允许访问的子域
                    a、默认不能夸域

        【配置方式】
            1)修改PHP.INI全局配置
            2)脚本中配置:PHP可以通过ini_set函数在允许中设置(只会对当前运行的项目有效)
                Ini_set('');

        【销毁SESSION】
            session_destroy()
            //会找到sessionID的文件并且删除
            sleep(5)
            //程序会暂停五秒后运行

        【session垃圾回收】
            //给session设定生命周期,最后修改时间与生命周期对比,到点自己滚
            1)session.gc_maxlifetime = 1400
                //规定到点session文件最大的生命周期是1440秒
            2)session.gc_probability=1:垃圾回收概率(分子)
            3)session.gc_divisor = 1000:垃圾回收概率(分母)
            //概率1/1000

        【无COOKIE使用SESSION】
            1)利用session_id();和session_name()来设置sessionID返回头的数据
                a、在session保存数据中获取
                    $id=session_id(); //获取id
                    $name=session_name(); //获取名字
                b、通过form表单或者gat超链接传到下一个文本
                    $ceho '<a href='xxxxxx?{$name}={$id}'>click</a>'
                c、获取sessionID(开启前)
                    $name=session_name();
                    $id=$_GET['name'];
                    //告知响应头需要的session
                    session_id($id);

            2)利用session提供的方法解决(php.ini配置)
                1)开启其它方式传输,关闭只允许cookie传输
                    a、session.use_trans_sid = 0    //开启改 1
                    b、session.use_only_cookies = 1 //关闭改0
                2)配置开启PHP后sessionID会自动绑定名字,(表单传值)
                    //声明
                    $_SESSION['xx']=xx;
                    //传输,会自己携带id
                     $ceho '<a href='xxxxxx'>click</a>'

/* GD图像处理 */(黑色才是无色)
    流程： //本质是开辟一个很大的内存空间制作图片
        1、准备画布
        2、开始做画
        3、保存内容
        4、销毁画布
    【创建画布】(返回资源,声明运用)
        1)ImageCreate(宽,高)//创建空白画布(背景白)
        2)ImageCreateTrueColor(宽,高)//创建真彩画布(背景黑)
        3)ImageCreatefrom[Jpeg/Gif/Png](文件路径)//打开图片文件
    
        【操作画布资源】(都需要资源变量)
            1)分配颜色:imageColorAllocate()
                //RGB三色分配,返回颜色句柄
            //以下操作都需要分配颜色
            2)填充背景:imageFill(资源,始x,始y,颜色)
                //指定位置开始填充,填充相邻颜色的
            3)画直线:imageLine(资源,始x,始y,终x,终y,颜色)
            4)画矩形:imageRectangle(资源,在上x,左下y,右上x,右下y,颜色)
            5)画圆弧:imageArc(资源,始x,始y,w宽,h高,s开始角度,e结束角度,颜色)
            6)在画布上写字:
                imageString(资源,大小[1-5],始x,始y,内容,颜色)//书写ASCII对应字符(英)
                imageTtfText(资源,大小,始x,始y,旋转角度,颜色,字体,内容)//书写任意字符(中)
    【输出画布资源】
        1)输出为图片文件:以图片格式保存到本地文件夹 、
            a、mage[jpeg/gif/Png](资源,路径文件名)  
        2)输出为网页图片:将图片展示给HTML(用户)
            a、 header('Content-type:image/png');//声明格式
            b、mage[jpeg/gif/Png]()
    
    【销毁画布】
        //释放画布内存
        imagedestroy(资源)
    
    【获取图片信息】
    //先将图片转换成资源类型
        1)获取图片宽
            a、imagesx(资源);
        2)获取图片高
            a、imagesiy(资源);
        3)获取图片全部信息(用地址)
            getimagesize(图片地址);
            //返回数组
    【验证码】
        流程：
            1)实现验证码图片展示
                a、生成图片资源
                b、写入文字
                    imagettftext(资源,大小,角度,x,y,字符,内容)
                c、输出图片给浏览器
                b、销毁图片
            2)实现验证码文字的随机变化
            3)实现验证码文字颜色的随机变化
            4)实现验证码背景或者噪点感染
                a、imagesetpi(资源，大小，x，y，内容，颜色);
                    //干扰画点
                b、imagestring(资源，开始x，开始y，结束x，结束y，颜色)
                    //画线
            5)实现点击刷新验证码功能
    【接收验证码】
        1)点击更换验证码,让src重新请求php脚本
        <img src="./GD图片3_验证码.php" onclick="this.src='./GD图片3_验证码.php?'+Math.random()">
        //Math.random()是js的随机数，以上是随机数拼接

    【略缩图】
        //原理打开原图获取一个小一点尺寸的图片
        1)实现固定高度的略缩图
            a、得到一张原图资源
            b、得到一张略缩图资源
                imagecopyresampled(缩略图资源,原图资源,缩略图开始x,缩略图开始y,原图采样x,原图采样y,缩略图存放宽,缩略图存放高,原图采样宽,原图采样高)
            c、图片采样复制;GD提供了一个函数
            d、保存略缩图
            e、销毁所有资源(原图和缩略图)
        2)实现等比缩放的固定宽高的略缩图
            //优点不会变形
            a、计算缩略图宽高比
            b、计算原图宽高比
            c、如果略缩图宽高大于原图，高是等比的但是宽不够会补白
            d、如果缩略图小于原图宽高比，将缩略图用原图的宽尽可能填满,宽是完整的,高度不够
            e、将图片放到缩略图
            案例:
                //略缩图宽高
                    $thumb_x = $thumb_y = 0;  //宽高
                    $start_x = $start_y = 0;  //图片开始位置
                //计算缩略图从原图采样宽高比(略缩图是宽还是高填满)
                    $thumb_b = 100 / 100;
                    $src_b = $src_info[0] / $src_info[1];
                //比较
                    if($thumb_b>=$src_b){
                        // 略缩图宽高比原图大
                        $thumb_y = 100;
                        $thumb_x = floor($src_b  *  $thumb_y);
                        //宽度需要调整(居中)
                        $start_x = floor((100 - $thumb_x)/2);
                    }else{
                        //略缩图宽高比原图小
                        $thumb_x = 100;
                        $thumb_y = floor($thumb_x / $src_b);
                        //宽度需要调整(居中)
                        $start_y = floor((100 - $thumb_y)/2);
                    }

    【水印图】
        //watermark:在图片上增加水印
        1)制作水印图的原理
            a、获取原图资源
            b、获取水印图资源
            c、合并两个资源成图片
                //图片合并
                imagecopymerge(目标资源,水印资源,水印开始x,水印开始Y,原图开始x,原图开始y,水印宽,水印高,透明度);
                //字体水印
                    1)设置透明颜色
                        $col = imagecolorallocatealpha($src,0,0,0,50);
                    2)给图片添加字符
                        imagestring(原图资源,大小,x,y,内容,颜色);

            d、保存输出
            e、清除
        2)实现现固定位置的水印图
        3)实现可选9个位置的水印图
    【封装水印图函数】

/**************************PHP核心编程END******************************/


/**************************PHP面向对象*********************************/
/* 类 */
    1)栈
        //用于存储变量名,变量被赋值指向堆的地址
    2)堆
        //存储属性值,没有栈指向时会被PHP回收
    【声明类】
        class 类名{
            <<内容>>
        }

    //实例化类(调用)对象保存在堆区
        $变量名 = new 类名[()];
    
    //类成员(存储数据)
        1)一级成员只能有 变量 方法(函数) 常量 构成
        2)实例化后调用变量不能带'$'符号
            public $name;
            //公共成员 变量、

            const PI = 3.14;
            //定义方法里的类常量

            $实例化变量名->(不带$)类变量名=xxx;
            //向实例化的变量传递值/添加属性(当前实例化的对象)互不干扰

            Unset($实例化变量名->(不带$)类变量名);
            //删除变量
    【访问修饰符】
    (尽量增加类对成员的控制,多用Protected,少用public )
        1)public 
        //公共属性,类的里外都可以访问
        2)protected
        //受保护,类内部才能访问
        3)private
        //私人的,只能在当的类使用

    【类方法(函数)】
        [全局变量引入局部]
            global 变量;
        [调用当前类的变量](内部指针)
            $this->(不带$)变量名
            //在方法里指向当前类的

    【构造函数】
         __construct()
        1)实例化的时候初始化属性(自动执行)
        public function __construct($a,$b){
            $this->count = $a;
            $this->money = $b;
        }
        2)实例化并且传参数;
        $s = new xxxx($a,$b);

    【析构函数】(比较少用,因为PHP执行完毕会回收)
        __destruct()
        //和构造函数一样系统会自动调用,当对象销毁时自动调用
        class Saler{
            protected $name;
            //析构方法 销毁时自动调用
            public function __destruct(){
                //销毁对象占用资源的代码
            }
        }
        $s = new Saler();
        unset($s);

    【对象传值】
        $s1 = new Saler();
        $s2 = $1;
        //$1的堆地址赋值给$s2,所以是共用一个堆(会互相影响)

    【范围解析操作符】(类常量访问)
        :://访问类的常量
        Saler::PI;(实例化也可以)

    【静态成员】(给类调用)
        1)添加static可以给变量和方法变成静态成员(只能类访问)
            //实例化调用静态函数也可以但是会报错(this也不行)
        2)类名 ::(范围解析操作符)+静态成员 进行访问
        3)静态成员是给类访问的,非静态成员是给对象访问的
        4)对象可以无条访问静态方法,类只能访问非$this的普通方法
        5)静态成员效率高(优先使用)

        static 被修饰变量/方法
        //一切基于static修饰的都是给类用的,没有对象的堆
        
        echo $s::PI;
        echo $s::$name;
        //实例化访问静态属性(类访问);
    
    【Self关键字】
        定义:
        1)Self是在类里面使用静态的方法,相当于给类使用的$this;(常量也行)
        2)可以在内部实例化对象,替换对象名(new self();这样子) 
            class Saler{
                public static $money = 100;

                public static function QsMoney(){
                    echo Saler::$money;
                    echo self::$money;
                    //相当于对象的this;
                }
            }
            Saler::QsMoney();
            //如果改变类名用self引用的方法就不用改

    【类的加载】
        class_exists()
        //判断内存中是否存在这个类
        file_exists()
        //文件或目录是否存在
        1)手动加载类
            include_once '类文件';

        2)自动加载类
             spl_autoload_register( '被调用的函数' );
            //自动连接类
            function load($CalssName){
                //可以做判断 $CalssName.'php';
                $c_file= '7.'.$CalssName.'类的加载.php';
                require_once $c_file;
            }
            spl_autoload_register( 'load' );
            //自动调用
            $s=new Saler();

            //用类实现自动加载
                class Autoload{
                    public static function loadC($CalssName){
                        $c_file= 'D:/New_MaI/php/PHP面向对象/7.'.$CalssName.'类的加载.php';
                        require_once $c_file;
                    }
                }
                 //用数组传入 变量名和参数
                spl_autoload_register( array('Autoload','loadC') );

    【克隆对象】
        clone;
        定义:直接在堆开辟一个新空间,把变量克隆到新的空间,自此两个对象互不干扰
            1)格式
                新对象 = clone 被克隆的对象;
        
        __clone;
        定义：在检测到产生新的克隆对象时自动调用
            1)格式
                public function __clone(){}
            2)禁止克隆(设置私有化就行了)
                private function __clone(){}

    【数据库连接类的封装】
        //详情在 PHP面向对象/10章类的封装
        1) query($sql)
            类执行sql语句
           
        2)fetch_all
            调用：return $res->fetch_all(MYSQLI_ASSOC);
            将所有结果行作为关联数组返回、数字数组或两者同时获取(二维数组))
        
        3)ferch_ASSOC()
            调用：return $res->ferch_ASSOC();
            获取结果行作为关联数组(一维数组)
        
        4)insert_id
            调用:$this->link->insert_id();
            //获取上传添加数据的自增长id

        5)affected_rows
            调用:$this->link->affected_rows;
            //获取上次修改影响的行数

        6)num_rows
            调用:$res(执行sql的变量)->num_rows;
            //获取上次查询结果的行数

    【设计模式】
        [单例](比较常用)
            //一个类只能产生一个对象,不能重复创建对象(数据的唯一性)
            简介：
                1)私有化构造方法:禁止无限创建对象
                2)私有化克隆方法:禁止无限克隆对象
                3)私有化静态属性:存储外部调用'入口'实例化的对象
                4)公有化静态方法:允许外部用类调用实例化对象

            1)INSTANCEOF 
                调用： 类::静态存储变量 INSTANCEOF 对象;
                //判断变量里是否存在指定对象
                //官方：用于确定一个 PHP 变量是否属于某一类 class 的实例
    
        [工厂模式]
            1)工厂模式是一种按需生产对象的模式
            2)工厂模式用于大型项目,需要运行功能差不多的类
            3)工厂模式优点方便后期维护(修改类名)
            4)工厂模式缺点大型项目类多的话工厂也会非常多
    
    【面向对象高级】
        简介：
            [封装]
                1)数据:操作的数据,变量,常量
                2)数据的操作(方法):方法和数据的操作捆绑到一起
                3)对外提供接口:可以给外部调用的公共方法
            [继承]
                1)父继子承,子类用父类的对象
                2)extends 继承标签
                    实例:class 子类 extends 父类{子类内容}
                3)继承可以节省代码,同时允许类中进行扩展,即增加父类没有的功能

            [多态](PHP不支持)
               1)java强类型 PHP弱类型
               2)类 a = new xxx
                    //输出的是子类方法,而不是类,这就是多态 
    
    【继承】
        总结：
            1)继承是有限的继承,是继承父系允许继承的部分(public)/(protected)
            2)子系继承父系的公共/保护/私有的变量，常量和静态属性，方法只能继承公共/保护
            3)构造方法和析构克隆等系统自动调用的也可以被继承
            4)父类的私有成员/方法本质是不能被访问的,但是可以通过子类访问父类的接口访问(本末倒置)
        详情：PHP面向对象/13.PHP继承

    【重写】
        总结：
            1)重写override是一种在子类中定义父类同名成员的操作
            2)公有和保护的属性重写是直接覆盖的,私有属性不能被重写(不被继承)
            3)公有和保护的方法会被重写(非覆盖)
            4)parent不能访问父类的属性(静态属性可以)
            5)被重写的方法权限不能高于父类方法,数量/类型必须要与父类一致
            6)可以通过 parent::方法名强制调用父系方法    
        详情：PHP面向对象/14.PHP方法重写

    【继承特点】
        总结：
            1)PHP不支持多继承,但是可以链式继承
            2)PHP中私有方法不能被继承
            3)PHP中允许继承父类的构造方法和析构

    【静态延迟绑定】
         总结：
            1)静态延迟绑定是指通过static对静态成员的绑定,在编译时不绑定调用时绑定调用的类
            2)静态延迟绑定对比的是静态绑定的self
            3)静态延迟绑定是根据不同调用的类进行调用,被调用的类的变量需要重写(看实例我都不知道我写了什么J8)
        实例：15.PHP静态延迟绑定

    【final关键字】(修饰)
        总结：
        1)final修饰的类无法被继承,被修饰的方法不能被从写
            案例:
                a、class final xxx{}
                b、public final function xxx(){}
        2)final修饰的类和方法不希望被修改,保证结构的完整性
        3)可以在一个更高的维度来保证事务的共通表现
    
    【Abstract关键字】
        总结:
            1)被Abstract修饰的类叫抽象类
            2)被Abstract修饰的类/方法,只能被继承不能被实例化
            3)抽象类是用来规范字类的
            4)抽象类里有抽象方法,被继承的子类也必须要要相同的类(重写)
            5)抽象类里可以定义变量和常量和方法,但是访问权限不能是私有
            6)抽象方法里不可以有方法体{};
        实例：16.abstract抽象类

    【interface接口】
        总结:
            1)interface 类名{}
                //声明接口
            2) class 类 implements 接口
                //实现接口
            3)接口只能被类实现,不能被实例化
            4)接口成员只有两种,接口常量和接口方法
            5)类实现接口的时候,要实现接口的全部方法不是实现的可以抽象化
            6)接口可以继承,而且可以多继承
            7)大项中 接口->抽象类->类
        实例:17.接口Interface
    
    【trait代码复用】
        总结:
            1)trait是用来实现代码复用的,不可以被实例化也不可以被继承
            2)trait里可以声明:变量(包含静态)方法(包含静态),但是不能声明常量
            3)权限设置public(公共),继承不了设置保护没用,私有访问不了
            4)trait是用来将公共代码提供给其他类使用的,而类使用trait的前提是加载trait
                //在目标类里 use 类名;来加载trait
            5)一个类可以使用多个trait
                例如：use x1,x2;
            6)属性不允许重复,方法覆盖重写
            7)多重重写优先级 类原声明的方法>trait加载>继承的
                //可以在trait里使用 parent::方法名 来强制采用继承方法
        实例:
            trait 名字{ 内容 }//声明
    【trait代码2】
            1)同时调用两个拥有相同方法名的trait,可以通过修改另一个方法名来分别使用
                实例:
                    use 类1,类2{
                        类1::方法名1 insteadof 类2;//单用这一行调用的是类1
                        类2::方法明2 as 别名;
                    }
            2)修改trait里方法/变量的权限
                实例：
                    use 类名1{
                        方法名 as public 别名
                        //本质是声明了另外一个方法,不会销毁原来的方法
                    }
            案例:18.trait公共池

    【属性重载入】(相当于银行前台)  
        总结：
            a、PHP的重载 是指对象在访问一下不允许访问或者是不存之的属性/方法
                会自动调用
            b、重载是保护程序的容错率(错误调用运行自己的魔术方法)
            c、重载只是一种对外部访问采取的一种机制,不需要全部实现
            d、重载分为变量重载和方法重载   
                函数名：
                    1)读属性错误的时候触发
                        __get($key);
                    2)写属性的时候触发
                        __set($key,$value);
                    3)外部调用isset()函数或empty函数的时候触发
                        __isset($key);
                    4)外部调用unset()删除函数的时候触发
                        __unser($key);
                    5)对象被当做普通变量输出或者链接时触发
                        __toString();要return返回值
            案例：19.变量重载
    
        [方法的重载入]
            函数名：
                1)普通方法不可调用的时候触发
                    __call($function_name,$args);
                2)静态方法不可调用的时候触发
                     __callStatic($function_name,$args);
    
    【对象遍历foreach】(不合理)
        总结：
            1)外部遍历只能遍历公有
            2)可以内部写个方法遍历所有变量
        案例：
            $m = new Man();
            foreach ($m as $k => $v){
                echo $k.':'.$v.'<br/>';
            } 
    
    【命名空间】
        总结:不同命名空间里可以存在相同变量名方法名的变量和方法(解决重名)
            1)声明命名空间,声明命名空间之前不能有任何代码
                //namespace 空间名
            2)一个脚本里可以有多个命名空间,但是一般只设置一个
            3)命名空间里可以定义同名的有函数,常量和类(结构),类机构不允许同名,被定义后成为空间元素
            4)空间里可以有其他代码
            5)命名空间就好比在磁盘里划分多个不同的文件夹用来保存同名文件
    
    【命名空间子空间】
        总结：子空间,在已经有的空间上划分2级小空间
            1)创建子空间
                //namespace 一级空间\二级空间
            2)可以直接创建二级空间
            3)子空间理论上可以无限创建,一般开发最多4层
        
    【命名空间访问】
        总结：
            1)命名空间的访问方式分为三种
            2)非限定名称访问,访问当前目录从下往上第一个命名空间,不能夸空间,
            3)限定名称访问,空间名\元素或函数,代表访问当前空间
                //如果当前有空间 会直接拼接 使用限定就相当于访问二级空间
            4)完全限定访问,\空间名\元素或函数 ,相当于从根目录访问

    【全局空间】
        总结:
            1)默认就是全局空间
            2)全局空间是没有名字的
            3)限定名称访问常量和函数时,找不到会尝试在全局空间查询(就是系统)系统定义的类不行要用完全限定访问
            4)非限定名称访问,已经定义空间的函数,会优先访问自身的空间,没有就往全局空间查询

    【命名空间引入】
         总结:
            1)引入空间元素,默认是从全局空间引入的
                use 空间名\空间元素 = \空间名\空间元素
            2)无条件引入类,函数和常量需要在前面加上function/const
                use function Human\display;
            3)如果引入的函数重名可以 as 改个别名
                use function Human\display1 as displays;
            4)复数引入,空间名后要加\
                use  Human\{
                    Man,                    //类
                    function display1,show, //函数
                    const PI,               //常量
                }
            5)可以引入空间,相当于当前空间的二级空间
                use Human; //相当于 Woman\space1\Human
                    echo Human\PI;
                    new Human\Man();
                    Human\show();

    【POD】
        总结:
            1)PDO::__construct;实例化一个PDO的对象
            2)PDO::exec;执行一个写入操作的SQL指令,返回受影响的行数
            3)PDO::query();执行一个读操作的SQL指令,返回一个PDOStatement类型对象(后台进行数据分析操作)
            4)PDO::errorCode();获取SQL错误代码
            5)PDO::errorlnfo();获取SQL错误描述
            6)PDO::lastInsertId();获取自增长ID
            7)PDO::fetch[all]();获取查询数据的1行[全部]
                //PDO::FETCH_ASSOC:返回一个引索为结果的数组(索引)
                //PDO::FETCH_NUM:返回数字下标的数组(数字)
                //PDO::FETCH_BOTH(默认):返回索引和数子下标的数组(返回2个)
    【PDP事务功能】
        总结:
            1)PDO::befinTransaction():开启事务
            2)PDO::exec();执行事务(写操作)
            3)PDO::rollBack();滚回所有事务
            4)PDO::commit();成功提交事务

    【PDO异常】
         总结:
            1)要使用PDO的异常抛出需要把PHP默认的警告弹出替换掉
                使用例:
                    1、回调函数设置
                    set_error_hadler(function()){
                        throw new Exception('错误');
                    }

                    2、设置默认获取数据样式
                    setFetchMode();
            2)使用PDO异常需要用try包含执行的代码和用catch捕获代码
                使用例:
                    try{
                        $res = $n1 / $n2;
                    }catch(Exception $e){
                        //抛出的函数
                        echo '错误文件'.$e->getFile().'<br/>';
                        echo '错误行'.$e->getLine().'<br/>';
                        echo '错误描述'.$e->getMessage().'<br/>';
                        die();
                    }
            3)getFile();错误文件
            4)getLine();错误行
            5)getMessage();错误描述
            6）如果变量为空或者是0
                使用例:
                     try{
                        if($n2 !=0){
                            $res = $n1 / $n2;
                        }else{
                            throw new Exception('不能为零');
                        }
                    }catch(Exception $e){
                        //抛出的函数
                        echo '错误文件'.$e->getFile().'<br/>';
                        echo '错误行'.$e->getLine().'<br/>';
                        echo '错误描述'.$e->getMessage().'<br/>';
                        die();
                    }
    
    【PDO错误机制】(SQL错误)
        总结：
            1)PDO提供了三种错误机制,是通过PDO常量PDO::ERRMODE来选择的
                a、PDO::ERRMODE_SILENT;静默模式,不会显示错误(PHP默认)
                b、PDO::ERRMODE_WARNING;警告模式,出错了马上给出错误警告
                c、PDO::ERRMODE_EXCEPTION;异常模式,出错了将错误交给异常PDOException对象
                实例:
                    $PDO(连接数据库变量)=setAttribute(PDO::ATTR_ERRMODE,PDO::ERRMODE_WARNING);
            2)捕获
                 try{
                        //SQL执行语句
                    }catch(PDOException $e){
                        //抛出的函数
                        echo '错误文件'.$e->getFile().'<br/>';
                        echo '错误行'.$e->getLine().'<br/>';
                        echo '错误描述'.$e->getMessage().'<br/>';
                        die();
                    }
    【POD异常处理SQL】
        总结:
            1)可以在连接数据库的时候设置异常抛出
                例:
                    $drivers = array(
                        //设置异常
                        PDD::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION;
                    )
                    //设置数据库
                    $pdo = new PDO('mysql:gost=localhost;port=3306;dbname=数据库名','账号'，'密码',$drivers)
            2)如果PDO实例化错误也可以抛出异常
                例:
                    try{
                        $pdo = new PDO('mysql:gost=localhost;port=3306;dbname=数据库名','账号'，'密码',$drivers)
                    }catch(Exception $e){
                        //抛出的函数
                        echo '错误文件'.$e->getFile().'<br/>';
                        echo '错误行'.$e->getLine().'<br/>';
                        echo '错误描述'.$e->getMessage().'<br/>';
                        die();
                    }
            3)遇到语法和逻辑没问题,但是数组不存在可以主动抛出异常
                例:
                    //封装报错
                    function my_exception(PDOException $e){
                        echo '错误文件'.$e->getFile().'<br/>';
                        echo '错误行'.$e->getLine().'<br/>';
                        echo '错误描述'.$e->getMessage().'<br/>';
                        die();
                    }
                    //异常函数
                    try{
                        //删除不存在的id
                       $res = $pdo->exec('delete from student where s_id = 100');
                        if(!$res){
                            throw new PDOException('删除错误,删除对象不存在')
                        }
                    }catch(Exception $e){
                        //抛出的函数
                       my_exception($e);
                    }
    
    【MySQL预处理】(MySQL)
        总结：用于大量语法相同,数组不同的情况,通过预处理省下无限次编译的性能消耗  
            1)发送预处理：prepare 预处理名 from 'SQL语句';
            2)执行语句:execute 预处理名;
            3)可以用占位符(?)来设置未知数值
                例：
                    prepare 预处理名 from 'select * from 表名 where id = ？  ';
            4)使用时需要设置变量,用using引入变量来调用预处理
                例：    
                    ser @id=1;
                    execute 预处理名 using @id;
        //以上操作在MySQL里执行

    【PDO封装预处理】
        总结：
            1)PDO中预处理提供了一套方法机制,主要由以下几个方法组成
                a、PDO::prepare();发送预处理指令,成功得到一个PDOstarement类对象,失败得到一个false(或异常)
                    例：
                        //声明预处理
                            $pre_sql = 'select * from 数据库 where s_id = :id';
                            //占位符可以用？或者:声明占位名
                        //发送预处理
                            $srmt = $PDO(实例化数据库对象)->prepare($pre_sql);

                b、PDOSratement::bindParam();绑定需要的参数,只能是变量(引用传递)
                    例: 
                        $stmt->bindValue('id'1[或者变量]);

                c、PDOSratement::bindValue();绑定需要的参数,可以绑定值(值传递)
                d、PDOSratement::execute();执行预处理,返回布尔值
                    例:
                        //执行预处理
                        $stmt->execute()
            2)如果是查询还需要利用farch转换成数组
                例:
                    $stmt->fetch(PDO::FETCH_ASSOC);

    【PDO预处理数据绑定】       
        总结：
            1)PDOSratement::execute();执行预处理的时候本身可以绑定数据
                例:
                    $stmt->execute(array(10[:id=>10]));
                    //?占位符使用,如果是：占位符,需要使用指定的占位符下标
            2)bindParam和bindValue的区别
                a、bindParam对变量的绑定是动态的,变量发生变化也会跟着变化(适合遍历)
                b、bindValue对变量是绑定死的,变量发生改变,也无法改变到当前绑定的值
    
    【PDO封装】
        总结
            1)明确PDO封装的内容
                1、使用命名空间方便使用
                2、PDO的实例化：得到PDO对象,PDO对象需要多次使用,可以考虑保存到属性中去
                3、写操作；包含普通的SQL执行,和返回收影响的行数和自增长ID
                4、查操作：包含单行查询和多行查询
                5、隐藏操作：异常处理的封装
                6、其他操作：根据实际需要的要求增加对应的功能
            2)开始封装
/**************************PHP面向对象END******************************/

/**************************MVC思想************************************/
/*MVC思想*/
    1)MVC是一种代码分离思想
    2)MVC是由控制器,模型,视图三部分组成
        ·控制器:负责所有事务处理,也包括模型和视图
        ·模型：只负责数据逻辑处理,包括操作数据库
        ·视图:只负责数据渲染,主要是HTML+js+jabascript
    3)通常状态下,面向对象中还会在模型和数据库之间加一层DAO(数据库连接,sql执行,异常抛出等底层)

/*MVC书写格式*/
    1)控制器的名字加上controller后缀,类也一样
        例:后台控制器
            namespace admin\controller;
            class xxxcontroller;

    2)模型的的名字加上model后缀,类也一样
        例:后台模型
            namespace admin\model;
            class xxxmodel;
        ·给模型里面加一个·表名·的属性,容易更改
    
    3)增加一个父类控制器用于存储初始化操作,成功/失败操作
        例:(公共控制器)
            namespace core;
            class Controller;

    4)增加一个模型控制器用于存储初始化操作,查询/多行查询操作
        例:(公共控制器)
            namespace core;
            class Model;

/*MVC单一入口*/
    1)单一入口是基于MVC思想实现的,用户请求就是根据业务的不同请求不同的控制器
    2)项目的单一入口,用户请求的一个PHP入口,其他事情都由入口文件分配
    3)项目单一文件能很好的保护文件结构的安全
    4)项目的单一文件会增加前期的开发难度,但相对于后期的维护与开发更加便捷

/**************************MVC思想END******************************/

/**************************Smarty模板技术******************************/
总结:
    1)用于前后端分离,用占位符替换html里的php标签
    2)需要下载配置和引入

/*模板技术原理*/
    1)找到HTML里指定的符号替换成PHP里的数据并输出
        例:
            //声明替换的数据
                $var = 'hello world';
            //获取HTML文件
                $str = file_get_contents('HTML文件');
            //对str的文件进行替换
                $str = Str_replace('占位符内容如[{$hello}]',$var,$str);
            //返回替换过的HTML文件
                echo $str;
    2)也可以替换成PHP标签
        例:
            $var = '<?phph echo $var; ?>';
    3)这就是替换的基本原理

/*Smarty模板技术*/
    1)优点
        ·效率高:提高网站的访问效率
        ·编译型:Smarty并非简单的替换,是重新编译的,效率更高
        ·缓存:Smarty可以使用缓存,在编译的基础上生成访问效率跟高的静态网页
        ·插件：允许开发人员自定义插件(通常不用);
        ·灵活：内置函数可以方便开发人员高效的实现数据显示
    2)缺点
        ·数据实时更新效率低,如果访问的数据是实时的,那么将大幅度降低访问效率
        ·不适合小项目,会让项目的开发增加难度,失去PHP快速开发的特点

/*Smarty模板简单应用*/
    1)下载的源文件只需要将libs放到PHP根目录即可(为方便区分改成Smaty)
    2)
        //加载Smarty类,实例化
            include_once 'Smarty\Smarty.class.php';
            $smarty = new Smarty();
        //提供数据
            $smarty->assign('需要替换的','被替换的内容');

        //显示模板数据
            $smarty->display('HTML模板地址');

/*Smarty配置*/
    1·$smarty->debugging = false;               //是否开启调试
    2·$smarty->template_dir = 'templates/';     //模板目录
    3·$smarty->compile_dir = 'templates_c';     //编译目录
    4·$smarty->config_dir = 'configs/';         //配置项目录
    5·$smarty->caching = false;                 //是否开启缓存('测试才开,不然刷新慢')
    6·$smarty->cache_dir = 'cache/';            //缓存目录
    7·$smarty->cache_lifetime = '3600' ;        //缓存生命周期
    8·$smarty->left_delimiter = '<{';           //左边界符
    9·$smarty->right_delimiter = '}>';          //右边界符
    
    总结：
        1)Smarty提供了很多控制方式,我们可以根据自己的需求来设定控制
        2)通常使用Smarty时,需要设置的就是模板路径和可能出现的分隔符冲突
        3)在项目开发阶段,一般不会开启缓存模式,如果生产环境数据的变更不频繁

/*模板变量*/
    1)在Smart模板中,我们将模板中的变量分为三类
        ·PHP分配变量,即利用asslgn方法分配的变量
        ·Smarty保留变量,包括超全局变量预定义变量和Smarty的内置变量
            ·GET数据；{$smarty.get.名字};
            ·POST数据:{$smarty.post.名字};
            ·session数据；{$smarty.session.名字}
            ·cookie数据：{$smarty.cookie.名字}
            ·REQUEST数据：{$smarty.require.名字}
            ·server数据：{$smarty.Server.大写名字}
            ·时间戳：{$smarty.now}
            ·模板路径：{$smarty.current_dir}
            ·模板名字：{$smarty.template}
            ·配置文件：{$smarty.config.配置名}

        ·自定义变量,用户在模板中去定义变量(通常不用)
            {assign var='hello[名字]' value='值'}
            {$hello}

        ·配置变量用txt设置,然后在模板文件里引入
            ·text
                //全局
                bodyBgColor = #00ff00

                //局部
                [customer]
                pageTitle = 'Customer Info';

            ·PHP
                //全局引入
                {config_loaf file='配置文件地址'}
                    <h1>{#bodyBgColor#}</h1>

                //局部引入
                {config_loaf file='配置文件地址' section='ustomer'}
                     <h1>{$smarty.config.配置名}</h1>

    2)PHP分配变量,理论上PHP可以分配任意数据类型,但通常数据只有三种
        ·标量数据:直接使用标记输出的数据
        ·数组数据：在smarty模板中可以使用下标或者通过'.'+下标来实现
        ·对象数据：在smarty模板中也是可以通过访问对象访问符来实现访问
    
/*内置函数*/
    1)分支处理：Smarty中提供了一套if分支用于判断(和mysql那个一样),语法格式{if}{else}{/if}
    2)采用smarty专用形式遍历数组
        {foreach from=$arr key=$k item=$v} 
            键:{$k},名字{$v}<br> 
        {/foreach}
    3)内置函数
        ·index：当前数组的索引(循环内部)
        ·iteration：当前循环的次数(循环内部)
        ·first：首次循环(循环内部)
        ·last:最后一次了循环(循环内部)
        ·show：循环是否执行判定,true表示循环有数据,false表示没有数据(未执行)
        ·total：foreach的执行总次数(循环内外部都可以使用)
        ·foreachelse：判断循环是否存在数据,不存在输出

    4)遍历引索数组,通常用于没有分配数据的循环
        {section name=名字 loop=传递数组|指定循环的次数[step=步长][max=最大循环次数]}
            {$传递数组[section名字].遍历下标}
        {/section}
            ·index：当前数组的索引(循环内部,受start和step影响)
            ·index_prev：当前数组的前一个引索(循环内部,受start和step影响)
            ·index_next:当前数组的最后一个引索(循环内部,受start和step影响)
            ·iteration：当前循环的次数(循环内部,受start和step影响)
            ·first：首次循环(循环内部,受start和step影响)
            ·last:最后一次了循环(循环内部,受start和step影响)
            ·rownum：iteration别名
            ·loop:最后一次循环的下标(内外)
            ·show：循环是否执行判定,true表示循环有数据,false表示没有数据(未执行)
            ·total：section执行的总次数(内外)


    5)文件包含:{include file='路径'}
    6)语法保护:{literal}{/literal},包含在里面的代码不会被解析成Smarty

/*外部函数使用*/
    1)可以在HTML里用{}包含PHP的函数进行使用
/**************************Smarty模板技术END***************************/

